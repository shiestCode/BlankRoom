# Stream

### 1.引子

可以先看看示例

```java
List<CrmAsset> assetList = mapper.getAssetByPage(searchAssetVO);
//资产的合同号列表
List<String> contractNumList = assetList.stream()
                                        .filter(t -> null != t.getContractNum())
                                        .distinct()
                                        .map(CrmAsset::getContractNum)
                                        .collect(Collectors.toList());
```

在示例里可以**Stream**的**基本操作过程**

 1.   集合对象**.stream()**	---->	生成一个Stream对象

 2.   对Stream对象进行相应**中间操作**,可能包含多个步骤

 3.   应用终端操作,产生结果,这个操作会强制执行之前的惰性操作

    ![](.\img\捕获1.PNG)

    ![](.\img\Stream.PNG)

    `流并不存储其元素`

    `流的操作不会修改器数据源`

    `流的操作是尽可能惰性执行`
    
    ------
    
    我们就从以上三步来学习Stream
    
    ------
    
    

### 2.stream()的创建

#### 数组转Stream

```java
String[] array = {"Monkey", "Lion", "Giraffe", "Lemur"};
Stream<String> nameStrs2 = Stream.of(array);

Stream<String> nameStrs3 = Stream.of("Monkey", "Lion", "Giraffe", "Lemur");
```

------

#### 集合转Stream

```java
public interface Collection<E> extends Iterable<E> {
    /**
     * 把调用他的集合作为数据源返回一个Stream对象
     *
     * Returns a sequential {@code Stream} with this collection as its source.
     *
     * @return a sequential {@code Stream} over the elements in this collection
     * @since 1.8
     */
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
}
```

可以看到stream()是在Collection接口里的,这就很方便,意味着Collection的子类都是实现了这个方法,都可以进行流创建

------

#### 文件转Stream

```java
Stream<String> lines = Files.lines(Paths.get("file.txt"));
```

------

#### 无限流

```java
//调用调用Stream.generate()，创建无限流，可以用来创建常量流,随机数流
Stream<Integer> stream5 = Stream.generate(() -> 10).limit(10);
```

```java
/**
     * Returns an infinite sequential unordered stream where each element is
     * generated by the provided {@code Supplier}.  This is suitable for
     * generating constant streams, streams of random elements, etc.
     * 
     * @param <T> the type of stream elements
     * @param s the {@code Supplier} of generated elements
     * @return a new infinite sequential unordered {@code Stream}
     */
    public static<T> Stream<T> generate(Supplier<T> s) {
        Objects.requireNonNull(s);
        return StreamSupport.stream(
                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);
    }
```



------

### 3.Stream操作



#### 筛选切片

| 函数名   | 解释                                                 |
| -------- | ---------------------------------------------------- |
| filter   | 从流中排除某些元素                                   |
| limit    | 使元素不超过指定数量                                 |
| skip     | 跳过前n个元素，如果流中元素不超过n个，则返回一个空流 |
| distinct | 通过hashCode()和equals()去除重复元素                 |



```java
/**
     * Returns a stream consisting of the elements of this stream that match
     * the given predicate.
     *
     * 返回一个Stream对象 能够匹配上 predicate 的
     *
     */
Stream<T> filter(Predicate<? super T> predicate);

```

[^Predicate]: 是谓语的意思,Stream中的各个元素是主语,位于是用来修饰主语的

```java
//主语:员工 谓语:年龄大于70 
public static Predicate<Employee> ageGreaterThan70 = x -> x.getAge() >70;
//主语:员工 谓语:性别为男
public static Predicate<Employee> genderM = x -> x.getGender().equals("M");
```

谓语还存在and(交集),or(并集),negate(取反)

```java
List<Employee> filtered = employees.stream()
        .filter(Employee.ageGreaterThan70.and(Employee.genderM))
        .collect(Collectors.toList());

List<Employee> filtered = employees.stream()
        .filter(Employee.ageGreaterThan70.or(Employee.genderM))
        .collect(Collectors.toList());

List<Employee> filtered = employees.stream()
        .filter(Employee.ageGreaterThan70.or(Employee.genderM).negate())
        .collect(Collectors.toList());
```

------

#### map映射

```java
/**
     * map函数的作用就是针对管道流中的每一个数据元素进行转换操作
     *
     * <p>This is an <a href="package-summary.html#StreamOps">intermediate
     * operation</a>.
     * map(T,R) ---> Stream<R>
     * @param <R> The element type of the new stream
     * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *               <a href="package-summary.html#Statelessness">stateless</a>
     *               function to apply to each element
     * @return the new stream
     */
    <R> Stream<R> map(Function<? super T, ? extends R> mapper);
```

![](.\img\捕获.PNG)

用于数据类型转化

![](.\img\捕获3.PNG)

对象数据的格式转化

```java
List<Employee> maped = employees.stream()
            .map(e -> {
                e.setAge(e.getAge() + 1);
                e.setGender(e.getGender().equals("M")?"male":"female");
                return e;
            }).collect(Collectors.toList());
```

peek是map在某种情况下的替代（函数没有返回值或者参数就是返回值的时候）

```java
    List<Employee> maped = employees.stream()
            .peek(e -> {
                e.setAge(e.getAge() + 1);
                e.setGender(e.getGender().equals("M")?"male":"female");
            }).collect(Collectors.toList());
```

Optional联动:

```java
Optional.ofNullable(assetInfo.getResult())
		.map(FeignCallAssetInfoDTO::getDevice)
         .map(Device::getModelName)
         .orElse(vo.getSopmodel());
//一层层的对象判空
//FeignCallAssetInfoDTO->Device->modelName其中有为null的吗?有的话就vo.getSopmodel()
```



------

#### reduce规约

```java
/**
*	用来实现集合元素的规约
*	@param identity    标识    规约操作的初始值 如果流为空，则为默认结果
*	@param accumulator 累加器  (规约的部分结果,流的下一个元素)归约运算的部分结果和流的下一个元素
*/
T reduce(T identity, BinaryOperator<T> accumulator);
```

![](.\img\捕获2.PNG)

```java
List<String> letters = Arrays.asList("a", "b", "c", "d", "e");
String result = letters
        .stream()
        .reduce("", (partialString, element) -> partialString + element);
```

------

#### match/find 匹配/查找

![](.\img\捕获4.PNG)

方法名即字面意思,直接返回boolean,谓词应该也不难理解

![](.\img\捕获5.PNG)

找到第一个/任意一个 一般直接搭配filter使用

最值

![](.\img\捕获7.PNG)

------

#### sorted排序

![](.\img\捕获6.PNG)

排序的记得自己实现一下比较器Comparator<? super T>

------

#### 并行流

![](.\img\173000a76224f5e7.png)

parallel()函数表示对管道中的元素进行并行处理

但是有些操作下并`不适合`使用并行操作

还记得最开始讲的`有状态操作`和`无状态操作`吗?

现在可以做出解释了

**无状态操作:每个元素的计算都不得依赖或影响任何其他元素的计算**

1.基础数据源无变化：在进行有状态操作时明显不适合使用并行操作。



2.适用于无状态操作：从文本文件里面边读边处理的场景，不适合parallel()并行处理。parallel()一开始就容量固定的集合，这样能够平均的拆分、同步处理。



3.数据源易拆分：从处理性能的角度，parallel()更适合处理ArrayList，而不是LinkedList。

[CompletableFuture]: .\CompletableFuture.md	" CompletableFuture"



------



### 4.Stream结果的处理

`注意当不执行终止操作的时候，中间操作不会执行`

#### collect元素收集在转化为集合类

```java
//我们一般使用Collectors中提供好的
<R, A> R collect(Collector<? super T, A, R> collector);
```

导航:Collectors就是这个类方法很多,用时可查

